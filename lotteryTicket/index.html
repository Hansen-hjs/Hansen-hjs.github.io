<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>彩票机选工具</title>
</head>
<style>
	*{ padding: 0px; margin: 0px; font-size: 16px; font-family: 微软雅黑; }
	div,ul,li,span,*:before,:hover{ transition: .4s all; }
	li{ list-style: none; }
	span{ display: block; }

	/*时间*/
	header{ width: 100%; height: 44px;}
	header h2{ font-size: 18px; text-align: center; line-height: 44px; color: #48acf8; font-weight: 400;}
	/*通用样式*/
	.content{ max-width: 500px; width: 100%; height: 250px; margin: 0 auto 20px; }
	.ball{ width: 100%; height: 100%; background-position: center; background-repeat: no-repeat; background-size: cover; position: relative; z-index: 1}
	.ball:before{ position: absolute; content: ""; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: -1; }
	.box_content{ width: 380px; height: 40px; margin: -20px -175px; overflow: hidden; position: absolute; top: 35%; left: 50%;}
	.box_content li{ float: left; width: 40px; height: 40px; margin-right: 10px; border-radius: 50%; color: #fff; text-align: center; line-height: 40px}
	.red{ background: #fb3f3f; }
	.bule{ background: #48acf8; }
	.create{ width: 150px; height: 40px; position: absolute; margin: -20px -75px; bottom: 35%; left: 50%; background: linear-gradient(to right, #fb3f3f, #48acf8); text-align: center; line-height: 40px; color: #fff; border-radius: 4px; cursor: pointer; }
	.create:hover{ background: linear-gradient(to right,#48acf8,#fb3f3f); transform: scale();}
	/*  */
	.swiper{ width: 100%; position: relative; background-color: #eee; overflow: hidden; }
	.swiper .swiper_list{ overflow: hidden; position: relative; width: 100%; }
	.swiper .swiper_slider{ float: left; width: 100%; background-color: #333; text-align: center; color: #fff; }
	.swiper img{ width: 100%; }
	.swiper .swiper_pagination{ position: absolute; left: 50%; bottom: 10px; height: 8px; -webkit-transform: translateX(-50%); transform: translateX(-50%); }
	.swiper .swiper_btn{ float: left; margin-left: 8px; width: 8px; height: 8px; background-color: rgba(0,0,0,0.5); border-radius: 50%; }
	.swiper .swiper_btn_active{ background-color: #fff; }
</style>
<body>
	<header>
		<h2 id="today_time"></h2>
	</header>
	<div class="swiper">
		<ul class="swiper_list">
			<li class="swiper_slider">
				<img src="./img/A7.jpg" alt="第一张图片">
			</li>
			<li class="swiper_slider">
				<img src="./img/A7.jpg" alt="第二张图片">
			</li>
			<li class="swiper_slider">
				<img src="./img/A7.jpg" alt="第三张图片">
			</li>
		</ul>
		<div class="swiper_pagination"></div>
	</div>
	<div class="content">
		<span class="ball" style="background-image: url(img/A7.jpg)">
			<ul class="box_content" id="bighappy">
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="bule">0</li>
				<li class="bule">0</li>
			</ul>
			<span class="create big_btn" onclick="bighappy('bighappy')">机选一组大乐透</span>
		</span>
	</div>
	<div class="content">
		<span class="ball" style="background-image: url(img/Arteon.jpg)">
			<ul class="box_content" id="twoColorBall">
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="bule">0</li>
			</ul>
			<span class="create two_btn" onclick="twoColorBall('twoColorBall')">机选一组双色球</span>
		</span>
	</div>
</body>
</html>
<script>
	// 红球生成数
	var red = [];
	function my_red(n,min,max){			// n是随机个数，min和max是数域
		for( i = 0; i < n; i++){
			red[i] = parseInt(Math.random()*(max-min+1)+min);
		}
		for( i=0; i < n; i++){
			for(j = i+1; j < n; j++){
				if(red[i] == red[j]){
					my_red(n,min,max);
					return false;
				}
			}
		}
	}
	// 蓝球生成数
	var blue = [];
	function my_blue(n,min,max){		// n是随机个数，min和max是数域
		for( i = 0; i < n; i++){
			blue[i] = parseInt(Math.random()*(max-min+1)+min);
		}
		for( i=0; i < n; i++){
			for(j = i+1; j < n; j++){
				if(blue[i] == blue[j]){
					my_blue(n,min,max);
					return false;
				}
			}
		}
	}
	// 大乐透
	function bighappy(bighappy) {
		my_red(5,1,35); 	// 红球
		my_blue(2,1,12);	// 蓝球
		var dlt_btn = document.getElementById(bighappy);
		var dlt_li = dlt_btn.getElementsByTagName('li');
		var Ball = '<li class="red">'
				+red[0]+
				'</li><li class="red">'
				+red[1]+
				'</li><li class="red">'
				+red[2]+
				'</li><li class="red">'
				+red[3]+
				'</li><li class="red">'
				+red[4]+
				'</li><li class="bule">'
				+blue[0]+
				'</li><li class="bule">'
				+blue[1]+'</li>';
		dlt_btn.innerHTML = Ball;
	  for (var i = 0; i < dlt_li.length; i++) {
			dlt_li[i].style.cssText = 'transform: scale(0.5,0.5); opacity: 0'
	  }
		setTimeout(function(){
			for (var i = 0; i < dlt_li.length; i++) {
				(function(j){
					setTimeout(function(){
						dlt_li[j].style.cssText = 'transform: scale(1,1); opacity: 1'
					},100 + 100 * j)
				})(i)
			}
		},200)
	}
	// 双色球
	function twoColorBall(twoColorBall){
		my_red(6,1,33); 	// 红球
		my_blue(1,1,16);	// 蓝球
		var ssq_btn = document.getElementById(twoColorBall);
		var ssq_li = ssq_btn.getElementsByTagName('li');
		var Ball = '<li class="red">'
				+red[0]+
				'</li><li class="red">'
				+red[1]+
				'</li><li class="red">'
				+red[2]+
				'</li><li class="red">'
				+red[3]+
				'</li><li class="red">'
				+red[4]+
				'</li><li class="red">'
				+red[5]+
				'</li><li class="bule">'
				+blue[0]+'</li>';
		ssq_btn.innerHTML = Ball;
		for (var i = 0; i < ssq_li.length; i++) {
			ssq_li[i].style.cssText = 'transform: scale(0.5,0.5); opacity: 0'
		}
		setTimeout(function(){
			for (var i = 0; i < ssq_li.length; i++) {
				(function(j){
					setTimeout(function(){
						ssq_li[j].style.cssText = 'transform: scale(1,1); opacity: 1'
					},100 + 100 * j)
				})(i)
			}
		},200)
	}

	setInterval(function () {
		var tTime = new Date();                                     // 今天时间
		var tMonth = ("0"+(tTime.getMonth()+ 1)).slice(-2);         // 今天月份
		var tDay = ("0"+tTime.getDate()).slice(-2);                 // 今天日期
		var tHours = ("0"+tTime.getHours()).slice(-2)								// 今天小时
		var tMinutes = ("0"+tTime.getMinutes()).slice(-2)						// 今天小时
		var tSeconds = ("0"+tTime.getSeconds()).slice(-2)						// 今天小时
		document.getElementById('today_time').innerHTML = tTime.getFullYear() + "-" + tMonth + "-" + tDay+" "+tHours+":"+tMinutes+":"+tSeconds;
	},1000)


	// var obj = 10;
	// (() => {
	// 	var obj = 20;
	// 	console.log(obj);
	// })();
	// (function aa(){
	// 	var obj = 30;
	// 	console.log(obj);
	// })();
	// var a;
	// (function(a){
	//   console.log(a);  //firebug输出123,使用（）运算符
	// })(123);
	// console.log(obj);
	const Swiper = {
		_pagination: false,
		_loop: false,
		_direction: false,
		_moveTime: 300,
		_autoPaly: false,
		_interval: 3000,
		init (_obj) {
			this._pagination = _obj.pagination || false;
			this._direction = _obj.direction || false;
			this._autoPaly = _obj.autoPaly || false;
			this._loop = _obj.loop || false;
			this._moveTime = _obj.moveTime || 300;
			this._interval = _obj.interval || 3000;
			if (!_obj.el) return console.log('没有可执行的元素！');
			this.format(_obj.el);
		},
		format (_el) {
			let _swiper = document.querySelector(_el);
			let _moveWidth = _swiper.offsetWidth;
			let _moveHeight = _swiper.offsetHeight;
			if (this._pagination) this.outputPagination(_swiper);
			if (this._loop) {
				this.outputLoop(_swiper,_moveWidth,_moveHeight);
			}else {
				this.layout(_swiper,_moveWidth,_moveHeight);
			}
		},
		// 动态布局 之后才有触摸事件
		layout (_div, _w, _h) {
			let _ul = _div.querySelector('.swiper_list');
			let _li = _div.querySelectorAll('.swiper_slider');
			if (this._direction) {
				for (let i = 0; i < _li.length; i++) {
					_li[i].style.height = _h + 'px';
				}
			}else {
				_ul.style.width = _w * _li.length + 'px';
				for (let i = 0; i < _li.length; i++) {
					_li[i].style.width = _w + 'px';
				}
			}
			this.touch(_div, _w, _h);
		},
		// 输出底部圆点
		outputPagination (_div) {
			let _btnList = _div.querySelector('.swiper_pagination');
			let _liNum = _div.querySelectorAll('.swiper_slider').length;
			let _html = '';
			for (let i = 0; i < _liNum; i++) {
				_html += '<div class="swiper_btn"></div>'
			}
			_btnList.innerHTML = _html;
			_btnList.querySelector('.swiper_btn').classList.add('swiper_btn_active');
		},
		// 如果要回路的话前后增加元素
		outputLoop (_div, _w, _h) {
			let _ul = _div.querySelector('.swiper_list');
			let _li = _ul.querySelectorAll('.swiper_slider');
			let _first = _li[0].cloneNode(true);
			let _last = _li[_li.length-1].cloneNode(true);
			_ul.insertBefore(_last, _li[0]);
			_ul.appendChild(_first);
			if (this._direction) {
				_ul.style.top = -_h + 'px';
			}else {
				_ul.style.left = -_w + 'px';
			}
			this.layout(_div, _w, _h)
		},
		// 触摸事件
		touch (_div, _w, _h) {
			let that = this;
			let _ul = _div.querySelector('.swiper_list');
			let _li = _ul.querySelectorAll('.swiper_slider')
			// 触摸开始时间，触摸结束时间，开始的距离，结束的距离，移动的距离，圆点位置
			let [sTime, eTime, _sd, _ed, _md, _index] = [0, 0, 0, 0, 0, 0];
			// 设置动画
			function hasAnimation() {
				_ul.style.WebkitTransition = that._moveTime/1000+'s all';
				_ul.style.transition = that._moveTime/1000+'s all';
			}
			// 关闭动画
			function noAnimation() {
				_ul.style.WebkitTransition = '0s all';
				_ul.style.transition = '0s all'
			}
			// 判断最大拖动距离 X
			function touchRangeX() {
				let _d = 0;
				if ((_ed - _sd) >= _w) {
					_d = _md + _w;
				}else if ((_ed - _sd) <= -_w) {
					_d = _md - _w
				}else {
					_d = _md + (_ed - _sd);
				}
				return _d;
			}
			// Y距离
			function touchRangeY () {
				let _d = 0;
				if ((_ed - _sd) >= _h) {
					_d = _md + _h;
				}else if ((_ed - _sd) <= -_h) {
					_d = _md - _h
				}else {
					_d = _md + (_ed-_sd);
				}
				return _d;
			}
			// 判断触摸处理函数 _d是距离X/Y
			function judgeTouch(_d) {
				//	这里我设置了120毫秒的有效拖拽间隔
				if ((eTime-sTime) < 120) return true;
				// 这里判断方向（正值和负值）
				if (_d < 0) {
					if ((_ed-_sd) < (_d/2)) return true;
					return false
				}else {
					if ((_ed-_sd) > (_d/2)) return true;
					return false
				}
			}
			// 返回原来位置
			function returnP () {
				hasAnimation();
				if (that._direction) {
					_ul.style.WebkitTransform = 'translate3d(0px, '+_md+'px, 0px)';
					_ul.style.transform = 'translate3d(0px, '+_md+'px, 0px)';
				}else {
					_ul.style.WebkitTransform = 'translate3d('+_md+'px, 0px, 0px)';
					_ul.style.transform = 'translate3d('+_md+'px, 0px, 0px)';
				}
			}
			// 移动
			function slideMove (_d) {
				let _btn = _div.querySelectorAll('.swiper_btn');
				hasAnimation();
				if (that._direction) {
					_ul.style.WebkitTransform = 'translate3d(0px, '+_d+'px, 0px)';
					_ul.style.transform = 'translate3d(0px, '+_d+'px, 0px)';
				}else {
					_ul.style.WebkitTransform = 'translate3d('+_d+'px, 0px, 0px)';
					_ul.style.transform = 'translate3d('+_d+'px, 0px, 0px)';
				}
				// 判断loop时回到第一张或最后一张
				if (that._loop && _index < 0) {
					// 我这里是想让滑块过渡完之后再重置位置所以加的延迟
					setTimeout(() => {
						noAnimation();
						if (that._direction) {
							_ul.style.WebkitTransform = 'translate3d(0px, '+_h*-(_li.length-3)+'px, 0px)';
							_ul.style.transform = 'translate3d(0px, '+_h*-(_li.length-3)+'px, 0px)';
							// 重置一下位置
							_md = _h*-(_li.length-3);
						}else {
							_ul.style.WebkitTransform = 'translate3d('+_w*-(_li.length-3)+'px, 0px, 0px)';
							_ul.style.transform = 'translate3d('+_w*-(_li.length-3)+'px, 0px, 0px)';
							_md = _w*-(_li.length-3);
						}
					},that._moveTime);
					_index = _li.length-3;
				}if (that._loop && _index > _li.length-3) {
					// 我这里是想让滑块过渡完之后再重置位置所以加的延迟
					setTimeout(() => {
						noAnimation();
						_ul.style.WebkitTransform = 'translate3d(0px, 0px, 0px)';
						_ul.style.transform = 'translate3d(0px, 0px, 0px)';
						// 重置一下位置
						_md = 0;
					},that._moveTime);
					_index = 0;
				}
				_div.querySelector('.swiper_btn_active').className = 'swiper_btn';
				_btn[_index].classList.add('swiper_btn_active');
			}
			// 判断移动
			function judgeMove() {
				// 判断是否需要执行过渡
				if (that._direction) {
					if (_ed < _sd) {
						// 往上拉
						if (judgeTouch(-_h)) {
							// 判断有loop的时候不需要执行下面的事件
							if (!that._loop && _md === -(_li.length-1) * _h) return returnP();
							_index += 1;
							slideMove(_md-_h);
							_md -= _h;
						}else returnP();
					}else {
						// 往下拉
						if (judgeTouch(_h)) {
							if (!that._loop && _md === 0) return returnP();
							_index -= 1;
							slideMove(_md+_h);
							_md += _h;
						}else returnP();
					}
				}else {
					if (_ed < _sd) {
						// 向左滑动
						if (judgeTouch(-_w)) {
							if (!that._loop && _md === -(_li.length-1) * _w) return returnP();
							_index += 1;
							slideMove(_md-_w);
							_md -= _w;
						}else returnP();
					}else {
						// 向右滑动
						if (judgeTouch(_w)) {
							if (!that._loop && _md === 0) return returnP();
							_index -= 1;
							slideMove(_md+_w);
							_md += _w;
						}else returnP();
					}
				}
			}
			// 开始触摸
			_ul.addEventListener('touchstart', ev => {
				sTime = new Date().getTime();
				noAnimation();
				if (that._direction) {
					_sd = ev.touches[0].pageY
				}else {
					_sd = ev.touches[0].pageX
				}
			});
			// 触摸移动
			_ul.addEventListener('touchmove', ev => {
				ev.preventDefault();
				if (that._direction) {
					_ed = ev.touches[0].pageY;
					_ul.style.WebkitTransform = 'translate3d(0px, '+touchRangeY()+'px, 0px)';
					_ul.style.transform = 'translate3d(0px, '+touchRangeY()+'px, 0px)';
				}else {
					_ed = ev.touches[0].pageX;
					_ul.style.WebkitTransform = 'translate3d('+touchRangeX()+'px, 0px, 0px)';
					_ul.style.transform = 'translate3d('+touchRangeX()+'px, 0px, 0px)';
				}
			});
			// 触摸离开
			_ul.addEventListener('touchend', () => {
				eTime = new Date().getTime();
				judgeMove()
			});
		}
	}
		/*
			这里我默认的所有参数都是false,需要时再true
			pagination: 底部圆点
			loop：是否需要回路
			direction：X/Y方向
			moveTime：过渡时间
			autoPaly： 自动播放
			interval： 自动播放间隔
		*/
		Swiper.init({
			el: '.swiper',
			pagination: true,
			autoPaly: true,
			// interval: 1000,
			loop: true,
			// moveTime: 4000,
			// direction: true
		})
</script>
