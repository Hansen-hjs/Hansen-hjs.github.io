<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>彩票机选工具</title>
</head>
<style>
	*{ padding: 0px; margin: 0px; font-size: 16px; font-family: 微软雅黑; }
	div,ul,li,span,*:before,:hover{ transition: .4s all; }
	li{ list-style: none; }
	span{ display: block; }

	/*时间*/
	header{ width: 100%; height: 44px;}
	header h2{ font-size: 18px; text-align: center; line-height: 44px; color: #48acf8; font-weight: 400;}
	/*通用样式*/
	.content{ max-width: 500px; width: 100%; height: 250px; margin: 0 auto 20px; }
	.ball{ width: 100%; height: 100%; background-position: center; background-repeat: no-repeat; background-size: cover; position: relative; z-index: 1}
	.ball:before{ position: absolute; content: ""; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: -1; }
	.box_content{ width: 380px; height: 40px; margin: -20px -175px; overflow: hidden; position: absolute; top: 35%; left: 50%;}
	.box_content li{ float: left; width: 40px; height: 40px; margin-right: 10px; border-radius: 50%; color: #fff; text-align: center; line-height: 40px}
	.red{ background: #fb3f3f; }
	.bule{ background: #48acf8; }
	.create{ width: 150px; height: 40px; position: absolute; margin: -20px -75px; bottom: 35%; left: 50%; background: linear-gradient(to right, #fb3f3f, #48acf8); text-align: center; line-height: 40px; color: #fff; border-radius: 4px; cursor: pointer; }
	.create:hover{ background: linear-gradient(to right,#48acf8,#fb3f3f); transform: scale();}
	/*  */
	.swiper{ width: 100%; position: relative; background-color: #eee; overflow: hidden; }
	.swiper .swiper_list{ overflow: hidden; position: relative; width: 100%; }
	.swiper .swiper_slider{ float: left; width: 100%; background-color: #333; text-align: center; color: #fff; }
	.swiper img{ width: 100%; }
	.swiper .swiper_pagination{ position: absolute; left: 50%; bottom: 10px; height: 8px; -webkit-transform: translateX(-50%); transform: translateX(-50%); }
	.swiper .swiper_btn{ float: left; margin-left: 8px; width: 8px; height: 8px; background-color: rgba(0,0,0,0.5); border-radius: 50%; }
	.swiper .swiper_btn_active{ background-color: #fff; }
</style>
<body>
	<header>
		<h2 id="today_time"></h2>
	</header>
	<div class="swiper">
		<ul class="swiper_list">
			<li class="swiper_slider">
				<img src="./img/A7.jpg" alt="第一张图片">
			</li>
			<li class="swiper_slider">
				<img src="./img/A7.jpg" alt="第二张图片">
			</li>
			<li class="swiper_slider">
				<img src="./img/A7.jpg" alt="第三张图片">
			</li>
		</ul>
		<div class="swiper_pagination"></div>
	</div>
	<div class="content">
		<span class="ball" style="background-image: url(img/A7.jpg)">
			<ul class="box_content" id="bighappy">
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="bule">0</li>
				<li class="bule">0</li>
			</ul>
			<span class="create big_btn" onclick="bighappy('bighappy')">机选一组大乐透</span>
		</span>
	</div>
	<div class="content">
		<span class="ball" style="background-image: url(img/Arteon.jpg)">
			<ul class="box_content" id="twoColorBall">
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="bule">0</li>
			</ul>
			<span class="create two_btn" onclick="twoColorBall('twoColorBall')">机选一组双色球</span>
		</span>
	</div>
</body>
</html>
<script>
	// 红球生成数
	var red = [];
	function my_red(n,min,max){			// n是随机个数，min和max是数域
		for( i = 0; i < n; i++){
			red[i] = parseInt(Math.random()*(max-min+1)+min);
		}
		for( i=0; i < n; i++){
			for(j = i+1; j < n; j++){
				if(red[i] == red[j]){
					my_red(n,min,max);
					return false;
				}
			}
		}
	}
	// 蓝球生成数
	var blue = [];
	function my_blue(n,min,max){		// n是随机个数，min和max是数域
		for( i = 0; i < n; i++){
			blue[i] = parseInt(Math.random()*(max-min+1)+min);
		}
		for( i=0; i < n; i++){
			for(j = i+1; j < n; j++){
				if(blue[i] == blue[j]){
					my_blue(n,min,max);
					return false;
				}
			}
		}
	}
	// 大乐透
	function bighappy(bighappy) {
		my_red(5,1,35); 	// 红球
		my_blue(2,1,12);	// 蓝球
		var dlt_btn = document.getElementById(bighappy);
		var dlt_li = dlt_btn.getElementsByTagName('li');
		var Ball = '<li class="red">'
				+red[0]+
				'</li><li class="red">'
				+red[1]+
				'</li><li class="red">'
				+red[2]+
				'</li><li class="red">'
				+red[3]+
				'</li><li class="red">'
				+red[4]+
				'</li><li class="bule">'
				+blue[0]+
				'</li><li class="bule">'
				+blue[1]+'</li>';
		dlt_btn.innerHTML = Ball;
	  for (var i = 0; i < dlt_li.length; i++) {
			dlt_li[i].style.cssText = 'transform: scale(0.5,0.5); opacity: 0'
	  }
		setTimeout(function(){
			for (var i = 0; i < dlt_li.length; i++) {
				(function(j){
					setTimeout(function(){
						dlt_li[j].style.cssText = 'transform: scale(1,1); opacity: 1'
					},100 + 100 * j)
				})(i)
			}
		},200)
	}
	// 双色球
	function twoColorBall(twoColorBall){
		my_red(6,1,33); 	// 红球
		my_blue(1,1,16);	// 蓝球
		var ssq_btn = document.getElementById(twoColorBall);
		var ssq_li = ssq_btn.getElementsByTagName('li');
		var Ball = '<li class="red">'
				+red[0]+
				'</li><li class="red">'
				+red[1]+
				'</li><li class="red">'
				+red[2]+
				'</li><li class="red">'
				+red[3]+
				'</li><li class="red">'
				+red[4]+
				'</li><li class="red">'
				+red[5]+
				'</li><li class="bule">'
				+blue[0]+'</li>';
		ssq_btn.innerHTML = Ball;
		for (var i = 0; i < ssq_li.length; i++) {
			ssq_li[i].style.cssText = 'transform: scale(0.5,0.5); opacity: 0'
		}
		setTimeout(function(){
			for (var i = 0; i < ssq_li.length; i++) {
				(function(j){
					setTimeout(function(){
						ssq_li[j].style.cssText = 'transform: scale(1,1); opacity: 1'
					},100 + 100 * j)
				})(i)
			}
		},200)
	}

	setInterval(function () {
		var tTime = new Date();                                     // 今天时间
		var tMonth = ("0"+(tTime.getMonth()+ 1)).slice(-2);         // 今天月份
		var tDay = ("0"+tTime.getDate()).slice(-2);                 // 今天日期
		var tHours = ("0"+tTime.getHours()).slice(-2)								// 今天小时
		var tMinutes = ("0"+tTime.getMinutes()).slice(-2)						// 今天小时
		var tSeconds = ("0"+tTime.getSeconds()).slice(-2)						// 今天小时
		document.getElementById('today_time').innerHTML = tTime.getFullYear() + "-" + tMonth + "-" + tDay+" "+tHours+":"+tMinutes+":"+tSeconds;
	},1000)


	// var obj = 10;
	// (() => {
	// 	var obj = 20;
	// 	console.log(obj);
	// })();
	// (function aa(){
	// 	var obj = 30;
	// 	console.log(obj);
	// })();
	// var a;
	// (function(a){
	//   console.log(a);  //firebug输出123,使用（）运算符
	// })(123);
	// console.log(obj);
	function Swiper (_params) {
		let [_pagination, _loop, _direction, _moveTime, _autoPaly, _interval] = [false, false, false, 300, false, 3000];
		// 触摸事件
		let touch = (_div, _w, _h) => {
			let _ul = _div.querySelector('.swiper_list');
			let _li = _ul.querySelectorAll('.swiper_slider');
			let _btn = _div.querySelectorAll('.swiper_btn');
			// 触摸开始时间，触摸结束时间，开始的距离，结束的距离，结束距离状态，移动的距离，圆点位置，自动播放定计算数值，loop定时器计算值
			let [sTime, eTime, _sd, _ed, _eState, _md, _index, _t, _loopNum] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
			// 选择方向距离
			let _distance = _direction ? _h : _w;
            // 定义 requestAnimationFrame
			window.myAnimation = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
			// 设置动画
			function hasAnimation() {
				_ul.style.WebkitTransition = _moveTime/1000+'s all';
				_ul.style.transition = _moveTime/1000+'s all';
			}
			// 关闭动画
			function noAnimation() {
				_ul.style.WebkitTransition = '0s all';
				_ul.style.transition = '0s all'
			}
            // 属性样式
			function slideStyle(_num) {
				if (_direction) {
					_ul.style.WebkitTransform = `translate3d(0px, ${_num}px, 0px)`;
					_ul.style.transform = `translate3d(0px, ${_num}px, 0px)`;
				}else {
					_ul.style.WebkitTransform = `translate3d(${_num}px, 0px, 0px)`;
					_ul.style.transform = `translate3d(${_num}px, 0px, 0px)`;
				}
			}
			// 判断最大拖动距离
			function touchRange() {
				let _num = 0;
				if ((_ed - _sd) >= _distance) {
					_num = _md + _distance;
				}else if ((_ed - _sd) <= -_distance) {
					_num = _md - _distance
				}else {
					_num = _md + (_ed - _sd);
				}
				return _num;
			}
			// 判断触摸处理函数 _d是距离X/Y
			function judgeTouch(_d) {
				//	这里我设置了200毫秒的有效拖拽间隔
				if ((eTime - sTime) < 200) return true;
				// 这里判断方向（正值和负值）
				if (_d < 0) {
					if ((_ed - _sd) < (_d/2)) return true;
					return false
				}else {
					if ((_ed - _sd) > (_d/2)) return true;
					return false
				}
			}
			// 返回原来位置
			function returnP () {
				hasAnimation();
				slideStyle(_md);
			}
			// 移动
			function slideMove (_d) {
				hasAnimation();
				slideStyle(_d);
				_loopNum = 0;
				// 判断loop时回到第一张或最后一张
				if (_loop && _index < 0) {
					// 我这里是想让滑块过渡完之后再重置位置所以加的延迟 (之前用setTimeout，快速滑动有问题，然后换成 requestAnimationFrame解决了这类问题)
					function loopMoveMin() {
						_loopNum += 1;
						if (_loopNum < _moveTime/1000*60) return myAnimation(loopMoveMin);
						noAnimation();
						slideStyle(_distance * -(_li.length-3));
						// 重置一下位置
						_md = _distance * -(_li.length-3);
					}
					loopMoveMin()
					_index = _li.length-3;
				}else if (_loop && _index > _li.length-3) {
					function loopMoveMax() {
						_loopNum += 1;
						if (_loopNum < _moveTime/1000*60) return myAnimation(loopMoveMax);
						noAnimation();
						slideStyle(0);
						_md = 0;
					}
					loopMoveMax()
					_index = 0;
				}
				_div.querySelector('.swiper_btn_active').className = 'swiper_btn';
				_btn[_index].classList.add('swiper_btn_active');
			}
			// 判断移动
			function judgeMove() {
				// 判断是否需要执行过渡
				if (_ed < _sd) {
					// 往上滑动 or 向左滑动
					if (judgeTouch(-_distance)) {
						// 判断有loop的时候不需要执行下面的事件
						if (!_loop && _md === -(_li.length-1) * _distance) return returnP();
						_index += 1;
						slideMove(_md - _distance);
						_md -= _distance;
					}else returnP();
				}else {
					// 往下滑动 or 向右滑动
					if (judgeTouch(_distance)) {
						if (!_loop && _md === 0) return returnP();
						_index -= 1;
						slideMove(_md + _distance);
						_md += _distance;
					}else returnP();
				}
			}
			// 自动播放移动
			function autoMove() {
				// 这里判断是否有回路loop的自动播放
				if (_loop) {
					_index += 1;
					slideMove(_md - _distance);
					_md -= _distance;
				}else {
					if (_index >= _li.length-1) {
						_index = 0;
						slideMove(0);
						_md = 0;
					}else {
						_index += 1;
						slideMove(_md - _distance);
						_md -= _distance;
					}
				}
			}
			// 首次开启自动播放
			function startAuto () {
				_t += 1;
				//	这里是1秒60次
				if (_t < _interval/1000*60) return myAnimation(startAuto);
				_t = 0;
				autoMove();
				startAuto()
			}
			if (_autoPaly) startAuto();
			// 开始触摸
			_ul.addEventListener('touchstart', ev => {
				// _loopNum = _moveTime/1000*60;
				[sTime, _t, _loopNum] = [new Date().getTime(), 0, _moveTime/1000*60]
				noAnimation();
				_sd = _direction ? ev.touches[0].pageY : ev.touches[0].pageX;
			});
			// 触摸移动
			_ul.addEventListener('touchmove', ev => {
				ev.preventDefault();
				_t = 0;
				_ed = _direction ? ev.touches[0].pageY : ev.touches[0].pageX;
				slideStyle(touchRange());
			});
			// 触摸离开
			_ul.addEventListener('touchend', () => {
				eTime = new Date().getTime();
				// 判断如果是点击的话就不执行移动
				if (_eState !== _ed) judgeMove();
				// 更新位置 && 重新打开自动播放要放到最后
				[_eState, _t] = [_ed, 0];
			});
		}
		// 动态布局
		let layout = (_div, _w, _h) => {
			let _ul = _div.querySelector('.swiper_list');
			let _li = _div.querySelectorAll('.swiper_slider');
			if (_direction) {
				for (let i = 0; i < _li.length; i++) {
					_li[i].style.height = _h + 'px';
				}
			}else {
				_ul.style.width = _w * _li.length + 'px';
				for (let i = 0; i < _li.length; i++) {
					_li[i].style.width = _w + 'px';
				}
			}
			touch(_div, _w, _h);
		}
		// 如果要回路的话前后增加元素
		let outputLoop = (_div, _w, _h) => {
			let _ul = _div.querySelector('.swiper_list');
			let _li = _ul.querySelectorAll('.swiper_slider');
			let _first = _li[0].cloneNode(true);
			let _last = _li[_li.length-1].cloneNode(true);
			_ul.insertBefore(_last, _li[0]);
			_ul.appendChild(_first);
			if (_direction) {
				_ul.style.top = -_h + 'px';
			}else {
				_ul.style.left = -_w + 'px';
			}
			layout(_div, _w, _h)
		}
		// 输出底部圆点
		let outputPagination = _div => {
			let _btnList = _div.querySelector('.swiper_pagination');
			let _liNum = _div.querySelectorAll('.swiper_slider').length;
			let _html = '';
			for (let i = 0; i < _liNum; i++) {
				_html += '<div class="swiper_btn"></div>'
			}
			_btnList.innerHTML = _html;
			_btnList.querySelector('.swiper_btn').classList.add('swiper_btn_active');
		}
		// 动态布局初始化
		let format = _el => {
			let _swiper = document.querySelector(_el);
			let _moveWidth = _swiper.offsetWidth;
			let _moveHeight = _swiper.offsetHeight;
			if (_pagination) outputPagination(_swiper);
			if (_loop) {
				outputLoop(_swiper,_moveWidth,_moveHeight);
			}else {
				layout(_swiper,_moveWidth,_moveHeight);
			}
		}
		// 配置传参
		let init = () => {
			_pagination = _params.pagination || false;
			_direction = _params.direction || false;
			_autoPaly = _params.autoPaly || false;
			_loop = _params.loop || false;
			_moveTime = _params.moveTime || 300;
			_interval = _params.interval || 3000;
			if (!_params.el) return console.log('没有可执行的元素！');
			format(_params.el);
		}
		init();
	}
		/*
			这里我默认的所有参数都是false,需要时再true
			pagination: 底部圆点
			loop：是否需要回路
			direction：X/Y方向
			moveTime：过渡时间
			autoPaly： 自动播放
			interval： 自动播放间隔
		*/
		new Swiper({
			el: '.swiper',
			pagination: true,
			autoPaly: true,
			// interval: 1000,
			loop: true,
			// moveTime: 4000,
			// direction: true
		})
</script>
