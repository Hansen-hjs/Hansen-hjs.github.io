<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>彩票机选工具</title>
</head>
<style>
	*{ padding: 0px; margin: 0px; font-size: 16px; font-family: 微软雅黑; }
	div,ul,li,span,*:before,:hover{ transition: .4s all; }
	li{ list-style: none; }
	span{ display: block; }

	/*时间*/
	header{ width: 100%; height: 44px;}
	header h2{ font-size: 18px; text-align: center; line-height: 44px; color: #48acf8; font-weight: 400;}
	/*通用样式*/
	.content{ max-width: 500px; width: 100%; height: 250px; margin: 0 auto 20px; }
	.ball{ width: 100%; height: 100%; background-position: center; background-repeat: no-repeat; background-size: cover; position: relative; z-index: 1}
	.ball:before{ position: absolute; content: ""; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: -1; }
	.box_content{ width: 380px; height: 40px; margin: -20px -175px; overflow: hidden; position: absolute; top: 35%; left: 50%;}
	.box_content li{ float: left; width: 40px; height: 40px; margin-right: 10px; border-radius: 50%; color: #fff; text-align: center; line-height: 40px}
	.red{ background: #fb3f3f; }
	.bule{ background: #48acf8; }
	.create{ width: 150px; height: 40px; position: absolute; margin: -20px -75px; bottom: 35%; left: 50%; background: linear-gradient(to right, #fb3f3f, #48acf8); text-align: center; line-height: 40px; color: #fff; border-radius: 4px; cursor: pointer; }
	.create:hover{ background: linear-gradient(to right,#48acf8,#fb3f3f); transform: scale();}
	/*  */
	.swiper{ width: 100%; position: relative; background-color: #eee; overflow: hidden; }
	.swiper .swiper_list{ overflow: hidden; position: relative; width: 100%; }
	.swiper .swiper_slider{ float: left; width: 100%; background-color: #333; text-align: center; color: #fff; }
	.swiper img{ width: 100%; }
	.swiper .swiper_pagination{ position: absolute; left: 50%; bottom: 10px; height: 8px; -webkit-transform: translateX(-50%); transform: translateX(-50%); }
	.swiper .swiper_btn{ float: left; margin-left: 8px; width: 8px; height: 8px; background-color: rgba(0,0,0,0.5); border-radius: 50%; }
	.swiper .swiper_btn_active{ background-color: #fff; }
</style>
<body>
	<header>
		<h2 id="today_time"></h2>
	</header>
	<div class="swiper">
		<ul class="swiper_list">
			<li class="swiper_slider">
				<img src="./img/A7.jpg" alt="第一张图片">
			</li>
			<li class="swiper_slider">
				<img src="./img/A7.jpg" alt="第二张图片">
			</li>
			<li class="swiper_slider">
				<img src="./img/A7.jpg" alt="第三张图片">
			</li>
		</ul>
		<div class="swiper_pagination"></div>
	</div>
	<div class="content">
		<span class="ball" style="background-image: url(img/A7.jpg)">
			<ul class="box_content" id="bighappy">
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="bule">0</li>
				<li class="bule">0</li>
			</ul>
			<span class="create big_btn" onclick="bighappy('bighappy')">机选一组大乐透</span>
		</span>
	</div>
	<div class="content">
		<span class="ball" style="background-image: url(img/Arteon.jpg)">
			<ul class="box_content" id="twoColorBall">
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="red">0</li>
				<li class="bule">0</li>
			</ul>
			<span class="create two_btn" onclick="twoColorBall('twoColorBall')">机选一组双色球</span>
		</span>
	</div>
</body>
</html>
<script>
	// 红球生成数
	var red = [];
	function my_red(n,min,max){			// n是随机个数，min和max是数域
		for( i = 0; i < n; i++){
			red[i] = parseInt(Math.random()*(max-min+1)+min);
		}
		for( i=0; i < n; i++){
			for(j = i+1; j < n; j++){
				if(red[i] == red[j]){
					my_red(n,min,max);
					return false;
				}
			}
		}
	}
	// 蓝球生成数
	var blue = [];
	function my_blue(n,min,max){		// n是随机个数，min和max是数域
		for( i = 0; i < n; i++){
			blue[i] = parseInt(Math.random()*(max-min+1)+min);
		}
		for( i=0; i < n; i++){
			for(j = i+1; j < n; j++){
				if(blue[i] == blue[j]){
					my_blue(n,min,max);
					return false;
				}
			}
		}
	}
	// 大乐透
	function bighappy(bighappy) {
		my_red(5,1,35); 	// 红球
		my_blue(2,1,12);	// 蓝球
		var dlt_btn = document.getElementById(bighappy);
		var dlt_li = dlt_btn.getElementsByTagName('li');
		var Ball = '<li class="red">'
				+red[0]+
				'</li><li class="red">'
				+red[1]+
				'</li><li class="red">'
				+red[2]+
				'</li><li class="red">'
				+red[3]+
				'</li><li class="red">'
				+red[4]+
				'</li><li class="bule">'
				+blue[0]+
				'</li><li class="bule">'
				+blue[1]+'</li>';
		dlt_btn.innerHTML = Ball;
	  for (var i = 0; i < dlt_li.length; i++) {
			dlt_li[i].style.cssText = 'transform: scale(0.5,0.5); opacity: 0'
	  }
		setTimeout(function(){
			for (var i = 0; i < dlt_li.length; i++) {
				(function(j){
					setTimeout(function(){
						dlt_li[j].style.cssText = 'transform: scale(1,1); opacity: 1'
					},100 + 100 * j)
				})(i)
			}
		},200)
	}
	// 双色球
	function twoColorBall(twoColorBall){
		my_red(6,1,33); 	// 红球
		my_blue(1,1,16);	// 蓝球
		var ssq_btn = document.getElementById(twoColorBall);
		var ssq_li = ssq_btn.getElementsByTagName('li');
		var Ball = '<li class="red">'
				+red[0]+
				'</li><li class="red">'
				+red[1]+
				'</li><li class="red">'
				+red[2]+
				'</li><li class="red">'
				+red[3]+
				'</li><li class="red">'
				+red[4]+
				'</li><li class="red">'
				+red[5]+
				'</li><li class="bule">'
				+blue[0]+'</li>';
		ssq_btn.innerHTML = Ball;
		for (var i = 0; i < ssq_li.length; i++) {
			ssq_li[i].style.cssText = 'transform: scale(0.5,0.5); opacity: 0'
		}
		setTimeout(function(){
			for (var i = 0; i < ssq_li.length; i++) {
				(function(j){
					setTimeout(function(){
						ssq_li[j].style.cssText = 'transform: scale(1,1); opacity: 1'
					},100 + 100 * j)
				})(i)
			}
		},200)
	}

	setInterval(function () {
		var tTime = new Date();                                     // 今天时间
		var tMonth = ("0"+(tTime.getMonth()+ 1)).slice(-2);         // 今天月份
		var tDay = ("0"+tTime.getDate()).slice(-2);                 // 今天日期
		var tHours = ("0"+tTime.getHours()).slice(-2)								// 今天小时
		var tMinutes = ("0"+tTime.getMinutes()).slice(-2)						// 今天小时
		var tSeconds = ("0"+tTime.getSeconds()).slice(-2)						// 今天小时
		document.getElementById('today_time').innerHTML = tTime.getFullYear() + "-" + tMonth + "-" + tDay+" "+tHours+":"+tMinutes+":"+tSeconds;
	},1000)


	// var obj = 10;
	// (() => {
	// 	var obj = 20;
	// 	console.log(obj);
	// })();
	// (function aa(){
	// 	var obj = 30;
	// 	console.log(obj);
	// })();
	// var a;
	// (function(a){
	//   console.log(a);  //firebug输出123,使用（）运算符
	// })(123);
	// console.log(obj);
	const Swiper = {
			_pagination: false,
			_loop: false,
			_direction: false,
			_moveTime: 300,
			_autoPaly: false,
			_interval: 3000,
			init(_obj) {
				this._pagination = _obj.pagination || false;
				this._direction = _obj.direction || false;
				this._autoPaly = _obj.autoPaly || false;
				this._loop = _obj.loop || false;
				this._moveTime = _obj.moveTime || 300;
				this._interval = _obj.interval || 3000;
				if (!_obj.el) return console.log('没有可执行的元素！');
				this.format(_obj.el);
			},
			format(_el) {
				let _swiper = document.querySelector(_el);
				let _moveWidth = _swiper.offsetWidth;
				let _moveHeight = _swiper.offsetHeight;
				if (this._pagination) this.outputPagination(_swiper);
				if (this._loop) {
					this.outputLoop(_swiper, _moveWidth, _moveHeight);
				} else {
					this.layout(_swiper, _moveWidth, _moveHeight);
				}
			},
			// 动态布局 之后才有触摸事件
			layout(_div, _w, _h) {
				let _ul = _div.querySelector('.swiper_list');
				let _li = _div.querySelectorAll('.swiper_slider');
				if (this._direction) {
					for (let i = 0; i < _li.length; i++) {
						_li[i].style.height = _h + 'px';
					}
				} else {
					_ul.style.width = _w * _li.length + 'px';
					for (let i = 0; i < _li.length; i++) {
						_li[i].style.width = _w + 'px';
					}
				}
				this.touch(_div, _w, _h);
			},
			// 输出底部圆点
			outputPagination(_div) {
				let _btnList = _div.querySelector('.swiper_pagination');
				let _liNum = _div.querySelectorAll('.swiper_slider').length;
				let _html = '';
				for (let i = 0; i < _liNum; i++) {
					_html += '<div class="swiper_btn"></div>'
				}
				_btnList.innerHTML = _html;
				_btnList.querySelector('.swiper_btn').classList.add('swiper_btn_active');
			},
			// 如果要回路的话前后增加元素
			outputLoop(_div, _w, _h) {
				let _ul = _div.querySelector('.swiper_list');
				let _li = _ul.querySelectorAll('.swiper_slider');
				let _first = _li[0].cloneNode(true);
				let _last = _li[_li.length - 1].cloneNode(true);
				_ul.insertBefore(_last, _li[0]);
				_ul.appendChild(_first);
				if (this._direction) {
					_ul.style.top = -_h + 'px';
				} else {
					_ul.style.left = -_w + 'px';
				}
				this.layout(_div, _w, _h)
			},
			// 触摸事件
			touch(_div, _w, _h) {
				let that = this;
				let _ul = _div.querySelector('.swiper_list');
				let _li = _ul.querySelectorAll('.swiper_slider')
				// 触摸开始的距离;结束的距离;结束距离状态;触摸的时间;平移的距离;跳转的位置;触摸时间计时器id;自动播放定时器id
				let [_start, _end, _endState, _t, _moveP, _index, _Interval, _auto] = [0, 0, 0, 0, 0, 0, null, null];
				// 判断最大拖动距离 type为true时则 Y, false反之
				function touchRange(type) {
					let _d = 0;
					if (type) {
						if ((_end - _start) >= _h) {
							_d = _moveP + _h;
						} else if ((_end - _start) <= -_h) {
							_d = _moveP - _h
						} else {
							_d = _moveP + (_end - _start);
						}
					} else {
						if ((_end - _start) >= _w) {
							_d = _moveP + _w;
						} else if ((_end - _start) <= -_w) {
							_d = _moveP - _w
						} else {
							_d = _moveP + (_end - _start);
						}
					}
					return _d;
				}
				// 判断触摸处理函数 _d是距离X/Y
				function judgeTouch(_d) {
					//	这里我设置了120毫秒的有效拖拽间隔
					if (_t < 120) return true;
					// 这里判断方向（正值和负值）
					if (_d < 0) {
						if ((_end - _start) < (_d / 2)) return true;
						return false
					} else {
						if ((_end - _start) > (_d / 2)) return true;
						return false
					}
				}
				// 设置动画
				function hasAnimation() {
					_ul.style.WebkitTransition = that._moveTime / 1000 + 's all';
					_ul.style.transition = that._moveTime / 1000 + 's all';
				}
				// 关闭动画
				function noAnimation() {
					_ul.style.WebkitTransition = '0s all';
					_ul.style.transition = '0s all'
				}
				// 返回原来位置
				function returnP() {
					hasAnimation();
					if (that._direction) {
						_ul.style.WebkitTransform = 'translateY(' + _moveP + 'px)';
						_ul.style.transform = 'translateY(' + _moveP + 'px)';
					} else {
						_ul.style.WebkitTransform = 'translateX(' + _moveP + 'px)';
						_ul.style.transform = 'translateX(' + _moveP + 'px)';
					}
				}
				// 自动播放
				function autoPaly() {
					if (!that._autoPaly) return;
					// 这里判断是否有回路loop的自动播放
					if (that._loop) {
						// 判断X-Y方向
						if (that._direction) {
							_index += 1;
							slideMove(_moveP - _h);
							_moveP -= _h;
						} else {
							_index += 1;
							slideMove(_moveP - _w);
							_moveP -= _w;
						}
					} else {
						// 判断X-Y方向
						if (that._direction) {
							if (_index >= _li.length - 1) {
								_index = 0;
								slideMove(0);
								_moveP = 0;
							} else {
								_index += 1;
								slideMove(_moveP - _h);
								_moveP -= _h;
							}
						} else {
							if (_index >= _li.length - 1) {
								_index = 0;
								slideMove(0);
								_moveP = 0;
							} else {
								_index += 1;
								slideMove(_moveP - _w);
								_moveP -= _w;
							}
						}
					}
				}
				// 判断移动
				function judgeMove() {
					// 判断是否需要执行过渡
					if (that._direction) {
						if (_end < _start) {
							// 往上拉
							if (judgeTouch(-_h)) {
								// 判断有loop的时候不需要执行下面的事件
								if (!that._loop && _moveP === -(_li.length - 1) * _h) return returnP();
								_index += 1;
								slideMove(_moveP - _h);
								_moveP -= _h;
							} else {
								returnP()
							}
						} else {
							// 往下拉
							if (judgeTouch(_h)) {
								if (!that._loop && _moveP === 0) return returnP();
								_index -= 1;
								slideMove(_moveP + _h);
								_moveP += _h;
							} else {
								returnP()
							}
						}
					} else {
						if (_end < _start) {
							// 向左滑动
							if (judgeTouch(-_w)) {
								if (!that._loop && _moveP === -(_li.length - 1) * _w) return returnP();
								_index += 1;
								slideMove(_moveP - _w);
								_moveP -= _w;
							} else {
								returnP()
							}
						} else {
							// 向右滑动
							if (judgeTouch(_w)) {
								if (!that._loop && _moveP === 0) return returnP();
								_index -= 1;
								slideMove(_moveP + _w);
								_moveP += _w;
							} else {
								returnP()
							}
						}
					}
				}
				// 移动
				function slideMove(_d) {
					let _btn = _div.querySelectorAll('.swiper_btn');
					hasAnimation();
					if (that._direction) {
						_ul.style.WebkitTransform = 'translateY(' + _d + 'px)';
						_ul.style.transform = 'translateY(' + _d + 'px)';
					} else {
						_ul.style.WebkitTransform = 'translateX(' + _d + 'px)';
						_ul.style.transform = 'translateX(' + _d + 'px)';
					}
					// 判断loop时回到第一张或最后一张
					if (that._loop && _index < 0) {
						// 我这里是想让滑块过渡完之后再重置位置所以加的延迟
						setTimeout(() => {
							noAnimation();
							if (that._direction) {
								_ul.style.WebkitTransform = 'translateY(' + _h * -(_li.length - 3) + 'px)';
								_ul.style.transform = 'translateY(' + _h * -(_li.length - 3) + 'px)';
								// 重置一下位置
								_moveP = _h * -(_li.length - 3);
							} else {
								_ul.style.WebkitTransform = 'translateX(' + _w * -(_li.length - 3) + 'px)';
								_ul.style.transform = 'translateX(' + _w * -(_li.length - 3) + 'px)';
								_moveP = _w * -(_li.length - 3);
							}
						}, that._moveTime);
						_index = _li.length - 3;
					} if (that._loop && _index > _li.length - 3) {
						// 我这里是想让滑块过渡完之后再重置位置所以加的延迟
						setTimeout(() => {
							noAnimation();
							if (that._direction) {
								_ul.style.WebkitTransform = 'translateY(0px)';
								_ul.style.transform = 'translateY(0px)';
							} else {
								_ul.style.WebkitTransform = 'translateX(0px)';
								_ul.style.transform = 'translateX(0px)';
							}
							// 重置一下位置
							_moveP = 0;
						}, that._moveTime);
						_index = 0;
					}
					_div.querySelector('.swiper_btn_active').className = 'swiper_btn';
					_btn[_index].classList.add('swiper_btn_active');
				}
				// 首次开启
				_auto = setInterval(autoPaly, that._interval);
				// 开始触摸
				_ul.addEventListener('touchstart', ev => {
					clearInterval(_auto);
					noAnimation();
					// 开始计算触摸时间
					_Interval = setInterval(() => _t += 1, 1);
					if (that._direction) {
						_start = ev.touches[0].pageY
					} else {
						_start = ev.touches[0].pageX
					}
				});
				// 触摸移动
				_ul.addEventListener('touchmove', ev => {
					// 清除默认动作
					ev.preventDefault();
					// noAnimation();	// 一开始我把触摸时停止动画放在这里，不过好像没有达到我想要的效果，所以我放在了开始触摸事件那边
					if (that._direction) {
						_end = ev.touches[0].pageY;
						_ul.style.WebkitTransform = 'translateY(' + touchRange(true) + 'px)';
						_ul.style.transform = 'translateY(' + touchRange(true) + 'px)';
					} else {
						_end = ev.touches[0].pageX;
						_ul.style.WebkitTransform = 'translateX(' + touchRange(false) + 'px)';
						_ul.style.transform = 'translateX(' + touchRange(false) + 'px)';
					}
				});
				// 触摸离开
				_ul.addEventListener('touchend', () => {
					returnP();
					clearInterval(_Interval);
					// 判断如果是点击的话就不执行移动
					if (_endState !== _end) judgeMove();
					// 开启自动播放
					_auto = setInterval(autoPaly, that._interval);
					// 走完之后再更改触摸距离,重置触摸时间一定要写在最后
					[_endState, _t] = [_end, 0];
				});
			}
		}
		/*
			这里我默认的所有参数都是false,需要时再true
			pagination: 底部圆点
			loop：是否需要回路
			direction：X/Y方向
			moveTime：过渡时间
			autoPaly： 自动播放
			interval： 自动播放间隔
		*/
		Swiper.init({
			el: '.swiper',
			pagination: true,
			autoPaly: true,
			// interval: 1000,
			loop: true,
			// moveTime: 4000,
			// direction: true
		})
</script>
